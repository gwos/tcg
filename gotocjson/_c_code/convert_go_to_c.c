// Code that is used during conversion of Go types, enumerations, and
// data structures, but is not specific to any one generated package.

#include <string.h>	// for strcmp() and strlen()
#include <inttypes.h>	// for PRId64
#include <errno.h>	// for errno
#include <stdio.h>	// for &fprintf, stderr, and the like

#include "convert_go_to_c.h"

// If this routine fails to find any matching string within the array, it returns a negative result. 
// It doesn't log anything in that situation, both because the caller is going to need to check the
// result anyway for such an out-of-bound result, and because the calling code has a much better
// idea of the full context of what ought to be included in a log message.
int enumeration_value(const string const enum_string[], int enum_string_count, const char *enum_value_as_string) {
    int enum_value;
    // We don't bother to test against the value at index 0 because we treat that slot as a
    // universally-matching wildcard.  That provides a mechanism for designating an unknown value.
    for (enum_value = enum_string_count; --enum_value > 0; ) {
	if (!strcmp(enum_value_as_string, enum_string[enum_value])) {
	    break;
	}
    }
    return enum_value;
}

char *typeof_json_item(const json_t *json) {
    if (json == NULL) { return "NULL pointer"; }
    int type = json_typeof(json);
    switch (type) {
	case JSON_OBJECT : return "JSON_OBJECT";
	case JSON_ARRAY  : return "JSON_ARRAY";
	case JSON_STRING : return "JSON_STRING";
	case JSON_INTEGER: return "JSON_INTEGER";
	case JSON_REAL   : return "JSON_REAL";
	case JSON_TRUE   : return "JSON_TRUE";
	case JSON_FALSE  : return "JSON_FALSE";
	case JSON_NULL   : return "JSON_NULL";
    }
    static char buf[100];
    sprintf(buf, "UNKNOWN JSON TYPE %d", type);
    return buf;
}

// As a convenience for the caller, JSON_as_str() eats what is probably the last reference to
// the "json" object that is passed in.  That circumstance needs to be understood if you want to
// produce a JSON string in some context where you want the JSON object to stick around afterward.
// In that case, you must call json_incref(json) before calling the JSON_as_str() routine.
//
// That said, the string returned by this routine is dynamically allocated, so it eventually needs
// to be free()d by the calling application to avoid a memory leak.
string JSON_as_str(json_t *json, size_t flags) {
    char *result;
    if (!flags) {
	// FIX MAJOR:  These settings are for initial development use.
	// We probably want to change them for production use.
	// flags = JSON_SORT_KEYS | JSON_INDENT(4) | JSON_ENSURE_ASCII;
	flags = JSON_INDENT(4) | JSON_ENSURE_ASCII;
    }
    if (json == NULL) {
	// FIX MINOR:  This message is mostly for development use, to track down the true source of failure.
	(*external_logging_function)(external_logging_first_arg, FILE_LINE "in JSON_as_str, received a NULL pointer\n");
	result = NULL;
    }
    else {
	result = json_dumps(json, flags);
	json_decref(json);
    }
    return result;
}

// This implementation must be supplied outside of anything generated by our automatic conversion,
// because it is generic to all packages and not specific to any one converted package.  The
// implementation seems a bit squirrely, in that it allocates and populates a single pointer which
// in turn contains the address of the string, and it passes back the address of that allocated
// pointer (that points to the actual string).  This extra level of indirection (as opposed to
// directly passing back the "char *" address of the string instead), helps to keep consistency with
// the ways in which our generated conversion routines are called, so we don't have to special-case
// calls to this routine.  The cost of that consistency will be borne at run time, namely with the
// extra allocate/deallocate steps for the extra intermediate pointer cell.  We might in the future
// revisit this construction and allow ourselves to do such special-case optimization.
//
// Note that it will be up to the caller to dispose of (that is, free()) the pointer cell we allocate
// here and pass back, if we pass back a non-NULL pointer to that cell.
//
// FIX MAJOR:  Calling JSON_as_str() is perhaps a simplified implementation (but I don't understand
// yet why it's not working; that needs some diagnosis).  We could instead use our belief that we
// have in hand just a string-valued JSON object, and call either
// "const string str_ptr = json_string_value(json);" or do this:
/*
	string string;
	if (json_unpack(json, "s"
	    , &string
	) != 0) { 
	    ...
	} else {
	    ...
	}
*/
//
// FIX MAJOR:  Check what eventually happens to the memory allocated for the string itself.  Is that
// a pointer to memory controlled by the JSON object, that we never have to worry about free()ing
// separately ourselves?  Or do we need to keep track of it, and eventually run our own free() call?
//
string *JSON_as_string_ptr(json_t *json) {
    // string str_ptr = JSON_as_str(json, 0);
    const string str_ptr = json_string_value(json);
    string * string_ptr;
    if (str_ptr == NULL) {
	string_ptr = NULL;
    } else {
	string_ptr = (string *) malloc(sizeof(string));
	if (string_ptr != NULL) {
	    // FIX MAJOR:  why do we need this cast?  does it cause any downstream constraints?
	    *(const string *)string_ptr = str_ptr;
	}
    }
    return string_ptr;
}

bool is_bool_ptr_zero_value(const bool *bool_ptr) {
    return (
	bool_ptr == NULL || *bool_ptr == false
    );
}

bool is_int_ptr_zero_value(const int *int_ptr) {
    return (
	int_ptr == NULL || *int_ptr == 0
    );
}

bool is_int32_ptr_zero_value(const int32 *int32_ptr) {
    return (
	int32_ptr == NULL || *int32_ptr == 0
    );
}

bool is_int64_ptr_zero_value(const int64 *int64_ptr) {
    return (
	int64_ptr == NULL || *int64_ptr == 0
    );
}

bool is_float64_ptr_zero_value(const float64 *float64_ptr) {
    return (
	float64_ptr == NULL || *float64_ptr == 0.0
    );
}

bool is_string_ptr_zero_value(string const *string_ptr) {
    return (
	string_ptr == NULL || *string_ptr == NULL || **string_ptr == '\0'
    );
}

bool is_struct_timespec_ptr_zero_value(const struct_timespec *struct_timespec_ptr) {
    return (
	struct_timespec_ptr == NULL || (
	    struct_timespec_ptr->tv_sec  == 0 &&
	    struct_timespec_ptr->tv_nsec == 0
	)
    );
}

// Convert from/to:
// "struct timeval",  with time_t tv_sec (seconds) and suseconds_t tv_usec (microseconds) members
// "struct timespec", with time_t tv_sec (seconds) and long tv_nsec (nanoseconds) members
struct_timespec timeval_to_timespec(struct timeval timeval_timestamp) {
    struct_timespec timespec_timestamp = {timeval_timestamp.tv_sec, timeval_timestamp.tv_usec * NANOSECONDS_PER_MICROSECOND};
    return timespec_timestamp;
}

// Logically, we would want Transit data structures to generate a number in the JSON representation of a milliseconds timestamp.
// We use a string instead more or less for legacy reasons, to make it easier in other places in the code to transfer this data
// to similar Foundation REST API calls, without needing to look too closely at it.  From an implementation standpoint, the only
// difference is the presence or absence of the quoting characters, and the movement of the conversion between string-of-digits
// and an actual number between different layers of code.  So there's not any significant loss of efficiency involved.
json_t *struct_timespec_ptr_as_JSON_ptr(const struct_timespec *struct_timespec) {
    json_error_t error;
    size_t flags = 0;
    json_t *json;
    // When generating this code, we must special-case the field packing in this routine, based on the "struct_timespec"
    // field type.  Also, we must ensure that the numeric-to-string conversion handles a 64-bit number.
    char string_milliseconds_timestamp[60];
    if (struct_timespec) {
	int64_t numeric_millseconds_timestamp =
	    (struct_timespec->tv_sec  * MILLISECONDS_PER_SECOND) +
	    (struct_timespec->tv_nsec / NANOSECONDS_PER_MILLISECOND);
	// PRId64 is from C99 and <inttypes.h>, to automatically select the proper format for an int64_t
	snprintf(string_milliseconds_timestamp, sizeof(string_milliseconds_timestamp), "%"PRId64, numeric_millseconds_timestamp);
    }
    // As long as we are using a string representation, we encode a missing struct_timespec as a JSON null value.
    // We might in some future revision also encode a zero value as a JSON null value here.  In the meantime, we
    // depend on higher-level code to decide whether to even call this conversion in such cases.
    json = json_pack_ex(&error, flags, "s?"
	 , (struct_timespec ? string_milliseconds_timestamp : NULL) 
    );
    if (json == NULL) {
	(*external_logging_function)(external_logging_first_arg,
	    FILE_LINE "ERROR:  in struct_timespec_ptr_as_JSON_ptr, JSON packing failed:  text '%s', source '%s', line %d, column %d, position %d\n",
	    error.text, error.source, error.line, error.column, error.position);
    }
    return json;
}

// See struct_timespec_ptr_as_JSON_ptr() for why we are converting from a string instead of from a number in the JSON
// representation of the milliseconds timestamp.
struct_timespec *JSON_as_struct_timespec(json_t *json) {
    struct_timespec *timespec = (struct_timespec *)malloc(sizeof(struct_timespec));
    if (!timespec) {
	(*external_logging_function)(external_logging_first_arg, FILE_LINE "ERROR:  in JSON_as_struct_timespec, %s\n", "malloc failed");
    } else {
	int failed = 0;
	json_error_t error;
	size_t flags = 0;
	// When generating this code, we must special-case the field unpacking in this routine, based on the "struct_timespec"
	// field type.  Also, we must ensure that the string-to-numeric conversion handles a 64-bit number.
	//
	// We get back here a pointer to a read-only copy of the string inside the JSON data structures.
	// That means we don't need to deal explicitly with freeing that string.
	char *string_milliseconds_timestamp = NULL;
	if (json_unpack_ex(json, &error, flags, "s"
	    , &string_milliseconds_timestamp
	) != 0) {
	    (*external_logging_function)(external_logging_first_arg,
		FILE_LINE "ERROR:  in JSON_as_struct_timespec, JSON unpacking failed:  text '%s', source '%s', line %d, column %d, position %d\n",
		error.text, error.source, error.line, error.column, error.position);
	    failed = 1;
	} else if (string_milliseconds_timestamp == NULL) {
	    (*external_logging_function)(external_logging_first_arg,
		FILE_LINE "ERROR:  in JSON_as_struct_timespec, found a non-string, so could not convert to a number");
	    failed = 1;
	} else {
	    char *endptr;
	    errno = 0;
#if __WORDSIZE == 64
	    int64_t numeric_millseconds_timestamp = strtol(string_milliseconds_timestamp, &endptr, 10);
#elif __GLIBC_HAVE_LONG_LONG
	    int64_t numeric_millseconds_timestamp = strtoll(string_milliseconds_timestamp, &endptr, 10);
#else
	    #error "this compilation does not support the int64_t datatype"
#endif
	    if (errno) {
		// We don't bother to try to diagnose the specific failure; it should suffice to print the
		// string value under consideration and allow a human to identify the likely problem.
		(*external_logging_function)(external_logging_first_arg,
		    FILE_LINE "ERROR:  in JSON_as_struct_timespec, conversion of \"%s\" to a number failed", string_milliseconds_timestamp);
		failed = 1;
	    }
	    else {
		timespec->tv_sec  = (time_t) (numeric_millseconds_timestamp / MILLISECONDS_PER_SECOND);
		timespec->tv_nsec = (long)   (numeric_millseconds_timestamp % MILLISECONDS_PER_SECOND) * NANOSECONDS_PER_MILLISECOND;
	    }
	}
	if (failed) {
	    free(timespec);
	    timespec = NULL;
	}
    }
    return timespec;
}

void free_JSON(json_t *json) {
    if (json != NULL) {
	json_decref(json);
    }
}

// A future version of this library might use the iconv library to be more general.
// We have designed the API to the routines we supply here so that could be a seamless
// transition if we do need to support character encodings other than ISO-8859-1 at
// some point in the future.  The reason we're not using libiconv in this first pass
// is because the iconv doc says it could be unnecessarily slow using the default
// available modules, and we have not yet written a module that would do direct
// conversions for the encodings we are most likely to care about.  If we do use
// libiconv at some future time, the simple conversion routines here could form the
// basis for a module which would play nice in the libiconv context, removing the
// worry about performance for the conversions we most expect to use.

int C_strings_use_utf8 = 0;
static char *C_string_encoding = NULL;

static char * string_conversion_buffer = NULL;
static size_t string_conversion_buffer_len = 0;

int string_is_ascii(char *c_string) {
    unsigned char *ch = (unsigned char *) c_string;
    while (*ch && *ch <= '\x7F') {
	++ch;
    }
    return (*ch ? 0 : 1);
}

int set_C_string_encoding(char *encoding) {
    free(C_string_encoding);
    C_string_encoding = strdup(encoding);
    if (C_string_encoding == NULL) {
	C_strings_use_utf8  = 0;
        return -1;
    }
    C_strings_use_utf8 = !strcmp(C_string_encoding, "UTF-8") || !strcmp(C_string_encoding, "UTF8");;
    return 0;
}

// See https://www.utf8-chartable.de/unicode-utf8-table.pl for a table of character
// encodings between ISO-8859-1 and UTF-8.  Strangely, that table is hard to find
// in its fully expanded form on the Internet.  Those are the transformations we
// carry out here.

// At present, this routine mostly ignores the C_string_encoding and just converts
// ISO-8859-1 to UTF-8.  We may generalize our support for encodings in the future.
char *C_string_to_UTF_8(char *c_string) {
    // Despite our not otherwise using the C_string_encoding, we insist that it be
    // set by the application to prepare in advance for any future generalization.
    if (C_string_encoding == NULL) {
        return NULL;
    }
    // We don't bother to check the boolean C_strings_use_utf8 flag here.  Instead,
    // we assume the data-conversion routines have checked that themselves before
    // deciding they need to call this function.

    // ISO-8859-1 => UTF-8 character conversions:
    //
    // 0x00 .. 0x7F => 0x00      .. 0x7F
    // 0x80 .. 0xBF => 0xC2 0x80 .. 0xC2 0xBF
    // 0xC0 .. 0xFF => 0xC3 0x80 .. 0xC3 0xBF

    // We make our temporary buffer just over twice as long as the input string,
    // to allow for maximal expansion of an ISO-8859-1 string to the UTF-8 form.
    size_t string_len = strlen(c_string);
    size_t need_buffer_len = string_len * 2 + NUL_TERM_LEN;
    if (string_conversion_buffer_len < need_buffer_len) {
        char *new_buffer = realloc(string_conversion_buffer, need_buffer_len);
	if (new_buffer == NULL) {
	    // The old buffer has not been freed, so we don't want to assign the
	    // new_buffer pointer to string_conversion_buffer right now.  But at
	    // the same time, we might not have enough memory for the converted
	    // string to fit.  So we must declare defeat, and allow the calling
	    // application to deal with that.
	    return NULL;
	}
	else {
	    string_conversion_buffer = new_buffer;
	    string_conversion_buffer_len = need_buffer_len;
	}
    }

    unsigned char *in_byte  = (unsigned char *) c_string;
    unsigned char *out_byte = (unsigned char *) string_conversion_buffer;
    do {
        if (*in_byte < 0x0080) {
	    *out_byte++ = *in_byte;
	}
	else {
	    // See the chart below for these transforms.
	    *out_byte++ = '\xC0' | (*in_byte >> 6);
	    *out_byte++ = '\x80' | (*in_byte & '\x3F');
	}
    } while (*in_byte++);
    return string_conversion_buffer;
}

// The UTF_8_to_C_string() routine is fine as it stands, but in practice for
// the Go-to-C conversions we might need, an in-place conversion from UTF-8
// to ISO-8859-1 within the passed input string is probably easier to handle
// from a memory-management and less-copying point of view.  So it is unlikely
// that we will actually use the UTF_8_to_C_string() routine.  Instead, the
// UTF_8_to_C_string_in_place() routine is more likely to be used.

// At present, this routine mostly ignores the C_string_encoding and just converts
// UTF-8 to ISO-8859-1.  We may generalize our support for encodings in the future.
char *UTF_8_to_C_string(char *utf_8_string) {
    // Despite our not otherwise using the C_string_encoding, we insist that it be
    // set by the application to prepare in advance for any future generalization.
    if (C_string_encoding == NULL) {
        return NULL;
    }
    // We don't bother to check the boolean C_strings_use_utf8 flag here.  Instead,
    // we assume the data-conversion routines have checked that themselves before
    // deciding they need to call this function.

    // UTF-8 character conversions:
    //
    // 0x00      .. 0x7F      => 0x00 .. 0x7F
    // 0xC2 0x80 .. 0xC2 0xBF => 0x80 .. 0xBF
    // 0xC3 0x80 .. 0xC3 0xBF => 0xC0 .. 0xFF
    //
    // For good measure, just to cover all bases, any other UTF-8 character will be
    // translated into 0x3F (a "?" character), just to make the unexpected character
    // visible.  Logically, we could have used the ASCII SUB control character, but
    // as a control character, it likely would not be visible in many contexts,
    // making it that much harder to identify problems should they occur.

    // We assume the UTF-8 input string is NUL-terminated, just like an ordinary
    // ASCII or ISO-8859-1 C string would be.
    size_t buffer_len = strlen(utf_8_string);
    size_t need_buffer_len = buffer_len + NUL_TERM_LEN;
    if (string_conversion_buffer_len < need_buffer_len) {
        char *new_buffer = realloc(string_conversion_buffer, need_buffer_len);
	if (new_buffer == NULL) {
	    // The old buffer has not been freed, so we don't want to assign the
	    // new_buffer pointer to string_conversion_buffer right now.  But at
	    // the same time, we might not have enough memory for the converted
	    // string to fit.  So we must declare defeat, and allow the calling
	    // application to deal with that.
	    return NULL;
	}
	else {
	    string_conversion_buffer = new_buffer;
	    string_conversion_buffer_len = need_buffer_len;
	}
    }

    // A proper UTF-8 decoder, which is what we ought to be implementing here,
    // has to cope not just with actual UTF-8 encoded characters, but also with
    // the possibility that it might receive byte sequences that are not valid
    // UTF-8, and so should not be blindly decoded.  See for example:
    //
    //     https://en.wikipedia.org/wiki/UTF-8#Overlong_encodings
    //     https://en.wikipedia.org/wiki/UTF-8#Invalid_sequences_and_error_handling
    //
    // As a simple example of an overlong encoding, a 0xC0 or 0xC1 byte followed
    // by a byte with the high two bits being 10 could in theory be used as an
    // alternate form of a simple ASCII character in the range 0x00 through 0x7F.
    // But the rule allowing only the shortest possible encoding rules that out.
    // So if we do encounter some invalid encoding, we must reject it as best we
    // can, and do whatever we can to resynchronize the byte stream to the start
    // of the next valid UTF-8 codepoint.
    unsigned char *in_byte  = (unsigned char *) utf_8_string;
    unsigned char *out_byte = (unsigned char *) string_conversion_buffer;
    do {
        if (*in_byte < 0x0080) {
	    *out_byte++ = *in_byte;
	}
	else if (*in_byte == '\xC2') {
	    // We express the mask and comparison values as numbers with leading
	    // zeroes, to avoid any unintended sign extension.
	    if ((*++in_byte & 0x00C0) == 0x0080) {
		// This is a very special case, in which no bit masking or shifting
		// is needed to transform the input byte to the output byte.
		*out_byte++ = *in_byte;
	    }
	    else {
		// The initial byte of a two-byte sequence was not followed by a valid
		// next-byte.  So we don't try to decode that sequence as such; we just
		// ignore that initial byte.  To give some downstream indication that we
		// had a problem, we do plant our substitution character in place of the
		// bad decoding.  There is no harm in doing so, because we know that our
		// output buffer is long enough to hold this byte.
		*out_byte++ = '?';
		--in_byte;
	    }
	}
	else if (*in_byte == '\xC3') {
	    // We express the mask and comparison values as numbers with leading
	    // zeroes, to avoid any unintended sign extension.
	    if ((*++in_byte & 0x00C0) == 0x0080) {
		// In this rather special case, no bit shifting is needed to transform
		// the input byte to the output byte; only one more bit must be set.
		*out_byte++ = *in_byte | '\x40';
	    }
	    else {
		// See above for our handling of this invalid byte sequence.
		*out_byte++ = '?';
		--in_byte;
	    }
	}
	else {
	    // Assuming we got in a good UTF-8 string, just not one containing
	    // only codepoints in the ISO-8859-1 character set, we will at this
	    // point have two or more bytes to consume in the input string to
	    // properly sync with codepoint boundaries.
	    //
	    // Code Point (hex)    UTF-8 Bytes (binary)
	    // ------------------  -----------------------------------------------------
	    // 00000000..0000007F  0xxxxxxx
	    // 00000080..000007FF  110xxxxx 10xxxxxx
	    // 00000800..0000FFFF  1110xxxx 10xxxxxx 10xxxxxx
	    // 00010000..001FFFFF  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	    // 00200000..003FFFFF  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	    // 04000000..7FFFFFFF  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	    //
	    // As it happens, our simple algorithm here should also correctly clean up
	    // any malformed byte sequences as well.  It will swallow overlong encodings,
	    // too-short encodings, and any extra unexpected continuation bytes regardless
	    // of what the leading byte was, producing only one output substitution
	    // character for the entire sequence, good or bad.
	    //
	    *out_byte++ = '?';
	    // We express the mask and comparison values as numbers with leading
	    // zeroes, to avoid any unintended sign extension.
	    while ((*++in_byte & 0x00C0) == 0x0080) {
	        // do nothing
	    }
	    --in_byte;
	}
    } while (*in_byte++);
    return string_conversion_buffer;
}

int UTF_8_to_C_string_in_place(char *utf_8_string) {
    int bad_conversion = 0;

    // In this routine, we don't bother to check either the C_string_encoding setup
    // or the boolean C_strings_use_utf8 flag here.  Instead, we assume the overall
    // application and the data-conversion routines that will call this function
    // have properly initialized the system and checked that flag themselves before
    // deciding that this function must be called.

    // UTF-8 character conversions:
    //
    // 0x00      .. 0x7F      => 0x00 .. 0x7F
    // 0xC2 0x80 .. 0xC2 0xBF => 0x80 .. 0xBF
    // 0xC3 0x80 .. 0xC3 0xBF => 0xC0 .. 0xFF
    //
    // For good measure, just to cover all bases, any other UTF-8 character will be
    // translated into 0x3F (a "?" character), just to make the unexpected character
    // visible.  Logically, we could have used the ASCII SUB control character, but
    // as a control character, it likely would not be visible in many contexts,
    // making it that much harder to identify problems should they occur.

    // We assume the UTF-8 input string is NUL-terminated, just like an ordinary
    // ASCII or ISO-8859-1 C string would be.

    // A proper UTF-8 decoder, which is what we ought to be implementing here,
    // has to cope not just with actual UTF-8 encoded characters, but also with
    // the possibility that it might receive byte sequences that are not valid
    // UTF-8, and so should not be blindly decoded.  See for example:
    //
    //     https://en.wikipedia.org/wiki/UTF-8#Overlong_encodings
    //     https://en.wikipedia.org/wiki/UTF-8#Invalid_sequences_and_error_handling
    //
    // As a simple example of an overlong encoding, a 0xC0 or 0xC1 byte followed
    // by a byte with the high two bits being 10 could in theory be used as an
    // alternate form of a simple ASCII character in the range 0x00 through 0x7F.
    // But the rule allowing only the shortest possible encoding rules that out.
    // So if we do encounter some invalid encoding, we must reject it as best we
    // can, and do whatever we can to resynchronize the byte stream to the start
    // of the next valid UTF-8 codepoint.
    unsigned char *in_byte  = (unsigned char *) utf_8_string;
    unsigned char *out_byte = (unsigned char *) utf_8_string;
    do {
        if (*in_byte < 0x0080) {
	    *out_byte++ = *in_byte;
	}
	else if (*in_byte == '\xC2') {
	    // We express the mask and comparison values as numbers with leading
	    // zeroes, to avoid any unintended sign extension.
	    if ((*++in_byte & 0x00C0) == 0x0080) {
		// This is a very special case, in which no bit masking or shifting
		// is needed to transform the input byte to the output byte.
		*out_byte++ = *in_byte;
	    }
	    else {
		// The initial byte of a two-byte sequence was not followed by a valid
		// next-byte.  So we don't try to decode that sequence as such; we just
		// ignore that initial byte.  To give some downstream indication that we
		// had a problem, we do plant our substitution character in place of the
		// bad decoding.  There is no harm in doing so, because we know that our
		// output buffer is long enough to hold this byte.
		bad_conversion = 1;
		*out_byte++ = '?';
		--in_byte;
	    }
	}
	else if (*in_byte == '\xC3') {
	    // We express the mask and comparison values as numbers with leading
	    // zeroes, to avoid any unintended sign extension.
	    if ((*++in_byte & 0x00C0) == 0x0080) {
		// In this rather special case, no bit shifting is needed to transform
		// the input byte to the output byte; only one more bit must be set.
		*out_byte++ = *in_byte | '\x40';
	    }
	    else {
		// See above for our handling of this invalid byte sequence.
		bad_conversion = 1;
		*out_byte++ = '?';
		--in_byte;
	    }
	}
	else {
	    // Assuming we got in a good UTF-8 string, just not one containing
	    // only codepoints in the ISO-8859-1 character set, we will at this
	    // point have two or more bytes to consume in the input string to
	    // properly sync with codepoint boundaries.
	    //
	    // Code Point (hex)    UTF-8 Bytes (binary)
	    // ------------------  -----------------------------------------------------
	    // 00000000..0000007F  0xxxxxxx
	    // 00000080..000007FF  110xxxxx 10xxxxxx
	    // 00000800..0000FFFF  1110xxxx 10xxxxxx 10xxxxxx
	    // 00010000..001FFFFF  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	    // 00200000..003FFFFF  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	    // 04000000..7FFFFFFF  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	    //
	    // As it happens, our simple algorithm here should also correctly clean up
	    // any malformed byte sequences as well.  It will swallow overlong encodings,
	    // too-short encodings, and any extra unexpected continuation bytes regardless
	    // of what the leading byte was, producing only one output substitution
	    // character for the entire sequence, good or bad.
	    //
	    bad_conversion = 1;
	    *out_byte++ = '?';
	    // We express the mask and comparison values as numbers with leading
	    // zeroes, to avoid any unintended sign extension.
	    while ((*++in_byte & 0x00C0) == 0x0080) {
	        // do nothing
	    }
	    --in_byte;
	}
    } while (*in_byte++);
    return (bad_conversion ? -1 : (out_byte - (unsigned char *) utf_8_string));
}

void (*external_logging_function)(void *arg, const char *format_string, ...) = NULL;
void *external_logging_first_arg = NULL;

int register_logging_callback(void (*logging_function)(void *arg, const char *format_string, ...), void *actual_arg) {
    if (logging_function) {
        external_logging_function = logging_function;
	external_logging_first_arg = actual_arg;
	return 0;
    }
    return -1;
}

void initialize_data_conversions() {
    set_C_string_encoding("ISO-8859-1");

    //
    // Actual definitions of safe initial values.
    //
    //     int fprintf (FILE *__restrict __stream, const char *__restrict __format, ...);
    //     FILE *stderr;
    //
    register_logging_callback( ( void (*)(void *arg, const char *format_string, ...) ) &fprintf, stderr );
}

void terminate_data_conversions() {
    // This routine is defined mostly to provide a place to run iconv_close() if need be
    // in the future.  At present, there are no cleanup actions to take.
}


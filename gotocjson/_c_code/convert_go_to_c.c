// Code that is used during conversion of Go types, enumerations, and
// data structures, but is not specific to any one generated package.

#include <string.h>	// for strcmp()
#include <inttypes.h>	// for PRId64
#include <errno.h>	// for errno

#include "convert_go_to_c.h"

// If this routine fails to find any matching string within the array, it returns a negative result. 
// It doesn't log anything in that situation, both because the caller is going to need to check the
// result anyway for such an out-of-bound result, and because the calling code has a much better
// idea of the full context of what ought to be included in a log message.
int enumeration_value(const string const enum_string[], int enum_string_count, const char *enum_value_as_string) {
    int enum_value;
    // We don't bother to test against the value at index 0 because we treat that slot as a
    // universally-matching wildcard.  That provides a mechanism for designating an unknown value.
    for (enum_value = enum_string_count; --enum_value > 0; ) {
	if (!strcmp(enum_value_as_string, enum_string[enum_value])) {
	    break;
	}
    }
    return enum_value;
}

char *typeof_json_item(const json_t *json) {
    if (json == NULL) { return "NULL pointer"; }
    int type = json_typeof(json);
    switch (type) {
	case JSON_OBJECT : return "JSON_OBJECT";
	case JSON_ARRAY  : return "JSON_ARRAY";
	case JSON_STRING : return "JSON_STRING";
	case JSON_INTEGER: return "JSON_INTEGER";
	case JSON_REAL   : return "JSON_REAL";
	case JSON_TRUE   : return "JSON_TRUE";
	case JSON_FALSE  : return "JSON_FALSE";
	case JSON_NULL   : return "JSON_NULL";
    }
    static char buf[100];
    sprintf(buf, "UNKNOWN JSON TYPE %d", type);
    return buf;
}

// As a convenience for the caller, JSON_as_str() eats what is probably the last reference to
// the "json" object that is passed in.  That circumstance needs to be understood if you want to
// produce a JSON string in some context where you want the JSON object to stick around afterward.
// In that case, you must call json_incref(json) before calling the JSON_as_str() routine.
//
// That said, the string returned by this routine is dynamically allocated, so it eventually needs
// to be free()d by the calling application to avoid a memory leak.
string JSON_as_str(json_t *json, size_t flags) {
    char *result;
    if (!flags) {
	// FIX MAJOR:  These settings are for initial development use.
	// We probably want to change them for production use.
	// flags = JSON_SORT_KEYS | JSON_INDENT(4) | JSON_ENSURE_ASCII;
	flags = JSON_INDENT(4) | JSON_ENSURE_ASCII;
    }
    if (json == NULL) {
	// FIX MAJOR:  this message is just for development use, to track down the true source of failure
	printf(FILE_LINE "in JSON_as_str, received a NULL pointer\n");
	result = NULL;
    }
    else {
	result = json_dumps(json, flags);
	json_decref(json);
    }
    return result;
}

// This implementation must be supplied outside of anything generated by our automatic conversion,
// because it is generic to all packages and not specific to any one converted package.  The
// implementation seems a bit squirrely, in that it allocates and populates a single pointer which
// in turn contains the address of the string, and it passes back the address of that allocated
// pointer (that points to the actual string).  This extra level of indirection (as opposed to
// directly passing back the "char *" address of the string instead), helps to keep consistency with
// the ways in which our generated conversion routines are called, so we don't have to special-case
// calls to this routine.  The cost of that consistency will be borne at run time, namely with the
// extra allocate/deallocate steps for the extra intermediate pointer cell.  We might in the future
// revisit this construction and allow ourselves to do such special-case optimization.
//
// Note that it will be up to the caller to dispose of (that is, free()) the pointer cell we allocate
// here and pass back, if we pass back a non-NULL pointer to that cell.
//
// FIX MAJOR:  Calling JSON_as_str() is perhaps a simplified implementation (but I don't understand
// yet why it's not working; that needs some diagnosis).  We could instead use our belief that we
// have in hand just a string-valued JSON object, and call either
// "const string str_ptr = json_string_value(json);" or do this:
/*
	string string;
	if (json_unpack(json, "s"
	    , &string
	) != 0) { 
	    ...
	} else {
	    ...
	}
*/
//
// FIX MAJOR:  Check what eventually happens to the memory allocated for the string itself.  Is that
// a pointer to memory controlled by the JSON object, that we never have to worry about free()ing
// separately ourselves?  Or do we need to keep track of it, and eventually run our own free() call?
//
string *JSON_as_string_ptr(json_t *json) {
    // string str_ptr = JSON_as_str(json, 0);
    const string str_ptr = json_string_value(json);
    string * string_ptr;
    if (str_ptr == NULL) {
	string_ptr = NULL;
    } else {
	string_ptr = (string *) malloc(sizeof(string));
	if (string_ptr != NULL) {
	    // FIX MAJOR:  why do we need this cast?  does it cause any downstream constraints?
	    *(const string *)string_ptr = str_ptr;
	}
    }
    return string_ptr;
}

bool is_bool_ptr_zero_value(const bool *bool_ptr) {
    return (
	bool_ptr == NULL || *bool_ptr == false
    );
}

bool is_int_ptr_zero_value(const int *int_ptr) {
    return (
	int_ptr == NULL || *int_ptr == 0
    );
}

bool is_int32_ptr_zero_value(const int32 *int32_ptr) {
    return (
	int32_ptr == NULL || *int32_ptr == 0
    );
}

bool is_int64_ptr_zero_value(const int64 *int64_ptr) {
    return (
	int64_ptr == NULL || *int64_ptr == 0
    );
}

bool is_float64_ptr_zero_value(const float64 *float64_ptr) {
    return (
	float64_ptr == NULL || *float64_ptr == 0.0
    );
}

bool is_string_ptr_zero_value(string const *string_ptr) {
    return (
	string_ptr == NULL || *string_ptr == NULL || **string_ptr == '\0'
    );
}

bool is_struct_timespec_ptr_zero_value(const struct_timespec *struct_timespec_ptr) {
    return (
	struct_timespec_ptr == NULL || (
	    struct_timespec_ptr->tv_sec  == 0 &&
	    struct_timespec_ptr->tv_nsec == 0
	)
    );
}

// Convert from/to:
// "struct timeval",  with time_t tv_sec (seconds) and suseconds_t tv_usec (microseconds) members
// "struct timespec", with time_t tv_sec (seconds) and long tv_nsec (nanoseconds) members
struct_timespec timeval_to_timespec(struct timeval timeval_timestamp) {
    struct_timespec timespec_timestamp = {timeval_timestamp.tv_sec, timeval_timestamp.tv_usec * NANOSECONDS_PER_MICROSECOND};
    return timespec_timestamp;
}

// Logically, we would want Transit data structures to generate a number in the JSON representation of a milliseconds timestamp.
// We use a string instead more or less for legacy reasons, to make it easier in other places in the code to transfer this data
// to similar Foundation REST API calls, without needing to look too closely at it.  From an implementation standpoint, the only
// difference is the presence or absence of the quoting characters, and the movement of the conversion between string-of-digits
// and an actual number between different layers of code.  So there's not any significant loss of efficiency involved.
json_t *struct_timespec_ptr_as_JSON_ptr(const struct_timespec *struct_timespec) {
    json_error_t error;
    size_t flags = 0;
    json_t *json;
    // When generating this code, we must special-case the field packing in this routine, based on the "struct_timespec"
    // field type.  Also, we must ensure that the numeric-to-string conversion handles a 64-bit number.
    char string_milliseconds_timestamp[60];
    if (struct_timespec) {
	int64_t numeric_millseconds_timestamp =
	    (struct_timespec->tv_sec  * MILLISECONDS_PER_SECOND) +
	    (struct_timespec->tv_nsec / NANOSECONDS_PER_MILLISECOND);
	// PRId64 is from C99 and <inttypes.h>, to automatically select the proper format for an int64_t
	snprintf(string_milliseconds_timestamp, sizeof(string_milliseconds_timestamp), "%"PRId64, numeric_millseconds_timestamp);
    }
    // As long as we are using a string representation, we encode a missing struct_timespec as a JSON null value.
    // We might in some future revision also encode a zero value as a JSON null value here.  In the meantime, we
    // depend on higher-level code to decide whether to even call this conversion in such cases.
    json = json_pack_ex(&error, flags, "s?"
	 , (struct_timespec ? string_milliseconds_timestamp : NULL) 
    );
    if (json == NULL) {
	// FIX MAJOR:  invoke proper logging for error conditions, integrated with application logging
	fprintf(stderr,
	    FILE_LINE "ERROR:  in struct_timespec_ptr_as_JSON_ptr, JSON packing failed:  text '%s', source '%s', line %d, column %d, position %d\n",
	    error.text, error.source, error.line, error.column, error.position);
    }
    return json;
}

// See struct_timespec_ptr_as_JSON_ptr() for why we are converting from a string instead of from a number in the JSON
// representation of the milliseconds timestamp.
struct_timespec *JSON_as_struct_timespec(json_t *json) {
    struct_timespec *timespec = (struct_timespec *)malloc(sizeof(struct_timespec));
    if (!timespec) {
	// FIX MAJOR:  invoke proper logging for error conditions, integrated with application logging
	fprintf(stderr, FILE_LINE "ERROR:  in JSON_as_struct_timespec, %s\n", "malloc failed");
    } else {
	int failed = 0;
	json_error_t error;
	size_t flags = 0;
	// When generating this code, we must special-case the field unpacking in this routine, based on the "struct_timespec"
	// field type.  Also, we must ensure that the string-to-numeric conversion handles a 64-bit number.
	//
	// We get back here a pointer to a read-only copy of the string inside the JSON data structures.
	// That means we don't need to deal explicitly with freeing that string.
	char *string_milliseconds_timestamp = NULL;
	if (json_unpack_ex(json, &error, flags, "s"
	    , &string_milliseconds_timestamp
	) != 0) {
	    // FIX MAJOR:  invoke proper logging for error conditions, integrated with application logging
	    fprintf(stderr,
		FILE_LINE "ERROR:  in JSON_as_struct_timespec, JSON unpacking failed:  text '%s', source '%s', line %d, column %d, position %d\n",
		error.text, error.source, error.line, error.column, error.position);
	    failed = 1;
	} else if (string_milliseconds_timestamp == NULL) {
	    // FIX MAJOR:  invoke proper logging for error conditions, integrated with application logging
	    fprintf(stderr, FILE_LINE "ERROR:  in JSON_as_struct_timespec, found a non-string, so could not convert to a number");
	    failed = 1;
	} else {
	    char *endptr;
	    errno = 0;
#if __WORDSIZE == 64
	    int64_t numeric_millseconds_timestamp = strtol(string_milliseconds_timestamp, &endptr, 10);
#elif __GLIBC_HAVE_LONG_LONG
	    int64_t numeric_millseconds_timestamp = strtoll(string_milliseconds_timestamp, &endptr, 10);
#else
	    #error "this compilation does not support the int64_t datatype"
#endif
	    if (errno) {
		// We don't bother to try to diagnose the specific failure; it should suffice to print the
		// string value under consideration and allow a human to identify the likely problem.
		// FIX MAJOR:  invoke proper logging for error conditions, integrated with application logging
		fprintf(stderr, FILE_LINE "ERROR:  in JSON_as_struct_timespec, conversion of \"%s\" to a number failed", string_milliseconds_timestamp);
		failed = 1;
	    }
	    else {
		timespec->tv_sec  = (time_t) (numeric_millseconds_timestamp / MILLISECONDS_PER_SECOND);
		timespec->tv_nsec = (long) (numeric_millseconds_timestamp % MILLISECONDS_PER_SECOND) * NANOSECONDS_PER_MILLISECOND;
	    }
	}
	if (failed) {
	    free(timespec);
	    timespec = NULL;
	}
    }
    return timespec;
}

void free_JSON(json_t *json) {
    if (json != NULL) {
	json_decref(json);
    }
}

This subdirectory is here only on a temporary basis, to contain code which
is still work-in-progress with regard to serialization and deserialization
of C structures expressed as JSON in a manner which will be completely
compatible with corresponding Go structures.

Certain OS packages are needed.  In particular, you need the following
before beginning (these are not the actual package names):

    make
    tar
    autoconf
    libtool
    Go
    GCC (a recent version that supports C99 or C11 by default; I forget which)
    binutils (for things like "ar")

From a standing start, as checked out from Git, follow the yellow brick road:

    # Drop into the top-level WIP directory.
    cd serialization-wip

    # Make the Jansson library.  Header files and compiled library files for
    # use with the WIP code will be installed under the local/ subdirectory.
    # The Makefile for the C code we are generating knows to look there.
    make

    # Drop into the bottom-level WIP directory.  This is where the conversion
    # program and test program are being developed.
    cd gotocjson

    # Compile the Go conversion program.
    make

    # Compile the unit-test program.
    make unittest

    # Build everything necessary, and run the unit tests.
    make test

    # Cleanup targets.
    make clean
    make realclean

The existing code contains a lot of extra output which has been useful
during development to expose the innards of what is happening during
Go-code parsing, C-code generation, and testing.  The parts of this
that matter will be cleaned up and formalized at the end, once all Go
constructs we must support are in fact supported.  In the meantime,
having more clues available when things fail is helpful.

There is currently much debris left around during the development and
test process.  The most important files are:

    doc/README
	The file you are now reading.

    Makefile
	A makefile used to compile the C-language Jansson library used
	for generating and parsing JSON strings.

    jansson-2.12.tar.gz
	The upstream Jansson library.  It doesn't really belong in our
	checked-in code.  If this file is locally missing, the sibling
	Makefile will download the original file and rename it to this
	sensible name (the Jansson folks didn't follow the usual standard
	conventions, which makes for confusion).

    gotocjson/Makefile
	A makefile used to compile the conversion program and the
	unit-test program.  As part of that build, the conversion program
	is run on some of the .go files in this directory, to generate
	corresponding C header and code files.

    gotocjson/gotocjson.go
	The Go-to-C conversion tool.  For development/test purposes,
	this is built and invoked via the sibling Makefile.

	The program works by running the standard Go compiler's own
	parser, then walking the Abstract Syntax Tree that results to find
	the parts we are interested in.  Those parts are picked through
	to extract package imports, type definitions, const blocks, and
	structure definitions eith their field name, field types, and
	field tags.  That information is saved in other data structures
	which are more convenient to use during C-code generation.

	Because Go allows forward references to as-yet-undefined types
	and objects, while C does not, the conversion program runs a
	topological sort on the relationships between all the data types,
	so they can be output in a form which closely mirrors that of
	the original Go code but also satisfies the constraints of the
	C compiler.

	Output is split between a .h file, containing only declarations,
	and a .c file, containing both enumeration values represented
	as strings and the generated conversion functions.

    gotocjson/convert_go_to_c.h
    gotocjson/convert_go_to_c.c
	These files contain code that is needed for conversion of C
	data structures to and from JSON, but that is not specific
	to the particular Go-package code that is being targeted.
	The common parts have been factored out into these files
	so it can be represented only once in a compiled application.

    gotocjson/c.c
    gotocjson/m.c
    gotocjson/t.c
	These files are the manually-edited C code that I am using to
	work out all the details of exactly how the final generated
	C code should look, operate, and handle errors.  Essentially,
	this is a playpen where I can experiment.  That is absolutely
	necessary, because it's quite hard to see what code needs to
	be generated until you have a chance to test it in practice.
	In the final version, these files will be replaced with the
	generated config.c, milliseconds.c, and transit.c files that
	will have full coverage of all the packages, enumerations,
	data structures, and encode/decode routines that we need.

    gotocjson/config.go
        a stable copy of the TNG config.go file, here to insulate
	against random changes in the real copy until I've worked out
	how to handle all features we need to support

    gotocjson/milliseconds.go
        a stable copy of the TNG milliseconds.go file, here to insulate
	against random changes in the real copy until I've worked out
	how to handle all features we need to support

    gotocjson/transit.go
        a stable copy of the TNG transit.go file, here to insulate
	against random changes in the real copy until I've worked out
	how to handle all features we need to support

    gotocjson/unittest.c
	This is the basic unit-test program.  It contains a few large
	JSON strings that we decode into C structures, then encode those
	back into JSON and compare against the original JSON strings to
	verify that we get back exactly what we started with.

    gotocjson/enum.go
	used for testing the Go-language parsing, but not part of the
	ultimate deliverable

Some of the other files represent older development code that I am
presently still keeping around for reference as replacement code is
written.

Current limitations:

    The current iteration of the conversion tool collects the struct field
    tags as it walks the parse tree and saves them away for later use,
    but the tags are not yet used to modify the generation or parsing
    of JSON strings in the generated C code.  That will take a later
    iteration of development.

    One issue with the current playpen code is that when parsing
    JSON into C structures, we encounter strings that end up being
    referenced by the C structures.  However, those strings will
    disappear when we destroy the JSON (Jansson) objects that contain
    them after parsing the incoming JSON string.  For that reason, at
    the moment we have some json_decref(json); calls commented out.
    We will either need to strdup() such strings when assigning them
    to C structures to sidestep such aliasing, or modify the decoding
    API to also return the relevant JSON objects so their lifetime
    can be controlled by the calling application rather than just the
    conversion routines.  That is an improvement still in the wings.

    I am still working on the playpen code to convert lists of items,
    in either direction.  This is somewhat complicated by the use of
    pointers in certain places in the Go structures.

    Specific details on other issues and further code improvements
    are documented in the TASKS file.

Usage of generated routines:

    C code which is generated from Go data structures will declare a
    set of associated routines.  Their intended usage is as follows.
    In the following discussion, assume that you have a Go pkg.go
    source file containing the Go package named "pkg", and a
    structure within that package named "Struct".  These routines
    will be generated or #defined, and their respective declarations
    and definitions will be found in the generated pkg.h file.

    A C application will use two different code patterns when
    copying data between itself and a Go partner.

    (*) To send data, a pkg.Struct will be dynamically allocated by
	make_empty_pkg_Struct().  Its fields will be filled in by
	the application, either directly (including fields for any
	embedded structures) or by dynamically creating subsidiary
	objects with equivalent allocation routines for those
	structures and saving the pointers to those subobjects
	into the growing data structure.  It is assumed that
	all strings in the ptr.Struct object (and recursively,
	in its subobjects) will be dynamically allocated.
	The C code is expected to understand the various "List"
	forms and populate them appropriately, including calling
	make_empty_pkg_Struct_array() to dynamically allocate the
	necessary arrays of list elements.

    (*) Once the pkg.Struct is fully populated, the application will
        call pkg_Struct_ptr_as_JSON_str() to convert the assembly
        into a dynamically-allocated string containing the JSON
        that will be passed to the Go code via some mechanism.

    (*) Once the data transfer is complete, the application must
	free() the JSON string used to send data to the Go partner.

    (*) Once the data transfer is complete, the application must
	also call free_pkg_Struct_ptr_tree(pkg_Struct_ptr, NULL)
	to de-allocate the entire assembly.  In this case, since the
	pkg.Struct was manually assembled, there are no associated
	Jansson objects, so that second parameter must be NULL.

    (*) To receive data, the application must interact with its Go
	partner to fetch a dynamically-allocated JSON string.

    (*) The application will call JSON_str_as_pkg_Struct_ptr()
	to convert the JSON string to a dynamically-allocated
	pkg.Struct structure (and its subobjects).  The application
	can then walk the structure as needed to extract the data
	it cares about.

    (*) [This step is not completely clear yet.  We will clarify
	this step once we have implemented the receipt of some data
	from a Go partner.]  Once the data transfer is complete,
	the application must free() the JSON string used to receive
	data from the Go partner.

    (*) Once the data transfer is complete, the application must
	also call free_pkg_Struct_ptr_tree(pkg_Struct_ptr, json) to
	de-allocate the entire assembly.  In this case, since the
	pkg.Struct was automatically assembled from intermediate
	Jansson objects, that second parameter must be non-NULL,
	pointing to those objects.

    Routines for application code:

	pkg_Struct *make_empty_pkg_Struct();
	pkg_Struct *make_empty_pkg_Struct_array(n);

	    These two routines provide for the dynamic allocation
	    of memory for a single pkg.Struct object, and for the
	    creation of an array of such objects.  The created
	    objects are intentionally all zeroed out, to provide
	    the best general approximation of having each member
	    of the object default to its own native zero value.

	char *pkg_Struct_ptr_as_JSON_str(const pkg_Struct *pkg_Struct_ptr);

	    This routine converts the data in a pkg.Struct object
	    into a JSON string.  It is the principal routine intended
	    to be called from application code for that task.

	pkg_Struct *JSON_str_as_pkg_Struct_ptr(const char *json_str, json_t **json);

	    This routine converts a JSON string to a pkg.Struct
	    object and its subsidiary objects.	The address of a
	    "json_t *" pointer must be passed to this routine for use
	    in creating intermediate Jansson objects and tracking the
	    memory used during the conversion.	Memory for strings
	    in the generated pkg.Struct object is shared between that
	    object (and its sub-objects) and the Jansson objects.

	    Exposing the Jansson objects at this level is something
	    of an intrusion of the implementation into the definition
	    of the API.  This is considered acceptable because
	    otherwise lots of addiitional memory allocation and
	    copying would be required, for data that is likely to
	    be of only transient value.

	void free_pkg_Struct_ptr_tree(pkg_Struct *pkg_Struct_ptr, json_t *json);

	    This routine is intended for use by application code, to
	    free a single pkg.Struct object and all of its subsidiary
	    objects in one step.  If the pkg.Struct object was
	    obtained from a call to JSON_str_as_pkg_Struct_ptr(),
	    the Jansson objects that were created in that process
	    must be passed back here, so they can be deallocated at
	    the same time.  Conversely, if the pkg.Struct object was
	    manually constructed, a NULL should be passed for the
	    "json" argument.

	    This routine assumes that ALL strings, subsidiary
	    objects, and the pkg.Struct object itself have been
	    dynamically allocated.  All of them will be deallocated
	    in the one call.

    Internal routines, not intended to be called by application code:

	bool is_pkg_Struct_ptr_zero_value(const pkg_Struct *pkg_Struct_ptr);

	    This routine checks to see whether the content of the
	    specified pkg.Struct consists fully of zero values for
	    all of its fields.	This is important internally within
	    the code that converts objects to JSON, in support of
	    the "omitempty" property of Go struct field tags.

	void destroy_pkg_Struct_ptr_tree(pkg_Struct *pkg_Struct_ptr, json_t *json, bool free_pointers);

	    This is an internal routine used by the JSON conversion
	    code to recursively walk a given pkg.Struct object and
	    deallocate all the associated memory.  It should not
	    be called directly from application code.

	json_t *pkg_Struct_ptr_as_JSON_ptr(const pkg_Struct *pkg_Struct_ptr);

	    This is an internal routine that converts a pkg.Struct
	    object into equivalent Jansson structures, which can
	    then be serialized to an actual JSON string for data
	    exchange with external code.  This routine is not
	    intended to be called by application code.

	pkg_Struct *JSON_as_pkg_Struct_ptr(json_t *json); 

	    This is an internal routine that converts Jansson
	    structures into an equivalent pkg.Struct object, which
	    can then be examined by application code.  This routine
	    is not intended to be called by application code.

